use_osc "localhost", 12004# Welcome to Sonic Pi


##-----------------------------------------------------------------------------------------------------------------
##------------       NOTE GENERATION     - NO DIRECTION                                        --------------------
##-----------------------------------------------------------------------------------------------------------------


define :ntosym do |n|
  note_info(n).to_s.split(" ")[1][1..-2].to_sym
end

## This function pseudorandomly produces notes in one key
define :produce_notes do |midi, maj_or_min, note_length_list, odds_of_rest|
  
  ## E flat major scale
  eb_major_scale = scale(:eb3, maj_or_min).to_a
  
  ## Check if the starting MIDI note is in E flat major scale. If not, round to the closest note in the E flat major scale.
  starting_note = ntosym(midi)
  theme_note = midi
  if eb_major_scale.include?(starting_note)
    puts 'YAY YOURE IN KEY'
  else
    puts 'BOO YOU ARE OUT OF KEY'
    puts ' YOU ARE BEING ROUNDED FROM '
    puts midi
    starting_note = eb_major_scale.sort_by { |n| (n - midi).abs }[0]
    puts ' TO '
    puts starting_note
    theme_note = starting_note
  end
  
  octave_range = (theme_note-12)..(theme_note+12)
  scale_range = eb_major_scale.select { |n| octave_range.include?(n) }
  
  final_notes = []
  final_notes.push(theme_note)
  final_notes.push(theme_note)
  final_notes.push(theme_note)
  final_notes.push(theme_note)
  
  # Add random notes from the scale within the octave range
  note_length_list.each do |length|
    if one_in(odds_of_rest)
      final_notes.push(:r)
    else
      note = choose(scale_range)
      final_notes.push(ntosym(note))
    end
  end
  return final_notes
end
r1 = [1,1,1,1,1,1,1,1]

my_array = [1,1,1,1,1,1,1,1] * 2
r2 = my_array.map {|num| num / 3.0}

my_array = [1,1,1,1,1,1,1,1] * 6
r5 = my_array.map {|num| num / 7.0}


##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##------------       VOICE INPUT                                                   ------------------------------------------------------------------------------------------
##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

with_fx :reverb, mix: 0.5, room: 0.9 do
  synth :sound_in, sustain: 3600, amp: 0.7
end



##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##------------       RECIEVING INFORMATION FROM BROWSER                                             -------------------------------------------------------------------------
##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


live_loop :importdata do
  
  # sync functions from Mr Bomb Music Git hub athttps://github.com/mrbombmusic/sonic-pi-drum-rnn-gui.
  use_real_time
  a = sync "/osc*/notes"
  b = sync "/osc*/times"
  set :notes, a
  set :times, b
  puts a
  
  # my code
  
  my_synth = :kalimba
  
  ##| with_fx :wobble do
  with_fx :reverb, mix: 0.8, room: 0.9 do
    
    sync :heart_beat
    my_midi = a.first
    
    
    ##| use_synth :dsaw
    ##| in_thread do
    ##|   play my_midi, amp: 0.01, sustain: 20
    ##| end
    
    
    temp_a = (rrand(4, 6).round)
    arr_a = [1,1,1,1,1,1,1,1] * temp_a
    r_a = my_array.map {|num| num / temp_a}
    
    use_synth my_synth
    in_thread do
      # NOWWW hopefully it syncs
      # and then we are going to use the first note we get to generate a list
      with_fx :wobble,  wave: 2 do
        note_list_a = produce_notes my_midi, :major, r2, 2
        r2.length.times do
          play note_list_a.tick + 12, amp: 0.8
          sleep r2.tick
        end
      end
    end
    
    use_synth my_synth
    in_thread do
      
      # NOWWW hopefully it syncs
      # and then we are going to use the first note we get to generate a list
      note_list_c = produce_notes my_midi, :major, r5, 3
      r5.length.times do
        play note_list_c.tick + 24, amp: 0.8
        sleep r5.tick
      end
    end
    
    use_synth my_synth
    in_thread do
      
      # NOWWW hopefully it syncs
      # and then we are going to use the first note we get to generate a list
      note_list_b = produce_notes my_midi, :major, r1, 4
      r1.length.times do
        play note_list_b.tick, amp: 0.9
        sleep r1.tick
      end
    end
    
    
    use_synth my_synth
    in_thread do
      
      # NOWWW hopefully it syncs
      # and then we are going to use the first note we get to generate a list
      with_fx :wobble,  wave: 1 do
        note_list_d = produce_notes my_midi, :major, r1, 2
        r1.length.times do
          play note_list_d.tick, amp: 0.9
          sleep r1.tick
        end
      end
    end
    
  end
  ##| end
  
end


# we are going to stick this at the end of the file and go upwards from there

in_thread do
  loop do
    cue :heart_beat
    with_fx :wobble, wave: 0  do
      ##| with_fx :slicer do
      with_fx :reverb do
        sample :elec_plip, amp: 0.1
        play chord(:Eb, :major7), amp: 0.2
      end
    end
    ##| end
    sleep 2
  end
end


