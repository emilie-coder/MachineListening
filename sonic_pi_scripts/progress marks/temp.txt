use_osc "localhost", 12004# Welcome to Sonic Pi


##-----------------------------------------------------------------------------------------------------------------
##------------       NOTE GENERATION     - NO DIRECTION                                        --------------------
##-----------------------------------------------------------------------------------------------------------------

#This function pseudorandomly produces notes in one key
define :produce_notes do |midi, maj_or_min, note_length_list|
  
  # E flat major scale
  eb_major_scale = scale(:eb3, maj_or_min).to_a
  
  # Check if the starting MIDI note is in E flat major scale. If not, round to the closest note in the E flat major scale.
  starting_note = ntosym(midi)
  if not eb_major_scale.include?(starting_note) do
      closest_note = eb_major_scale.sort_by { |n| (n - midi).abs }[0]
      midi = note_info(closest_note)[:midi]
    end
    
    final_notes = []
    
    note_length_list.each do |length|
      note = choose(eb_major_scale)
      final_notes.push(ntosym(note))
    end
    
    return final_notes
  end
end


##-----------------------------------------------------------------------------------------------------------------
##------------       NOTE GENERATION     -   WE WANT DIRECTION                                      ---------------
##-----------------------------------------------------------------------------------------------------------------
## This function pseudorandomly produces notes in one key that either ascends and descends or vice versa

define :produce_directional_notes do |midi, maj_or_min, note_length_list, direction|
  ## CREDIT FOR THIS RANDOM GENERATOR: https://in-thread.sonic-pi.net/t/randomizing-the-random-seed-with-computer-clock-timer/5560
  use_random_seed Time.now.to_i
  
  # We learned about scale in class, but for further reference or to learn more, I reference:
  #     https://github.com/sonic-pi-net/sonic-pi/blob/dev/etc/doc/tutorial/08.3-Scales.md
  notes = scale(midi, maj_or_min)
  
  halfway = notes.length / 2
  final_notes = []
  
  
  # https://in-thread.sonic-pi.net/t/midilib-for-sonic-pi-and-generating-markov-chains-from-midis/5646/5
  # where each_with_index came from ^^ user Amiika
  
  note_length_list.each_with_index do |length, i|
    if direction == :up
      if i < halfway
        note = notes[i]
      else
        note = notes[notes.length - 1 - i]
      end
    else
      if i < halfway
        note = notes[notes.length - 1 - i]
      else
        note = notes[i]
      end
    end
    
    final_notes.push(note)
  end
  return final_notes
end



r1 = [1,1,1,1,1,1,1,1]

my_array = [1,1,1,1,1,1,1,1]
r2 = my_array.map {|num| num / 1.0}

my_array = [1,1,1,1,1,1,1,1] * 4
r5 = my_array.map {|num| num / 4.0}


##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##------------       VOICE INPUT                                                   ------------------------------------------------------------------------------------------
##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

with_fx :reverb, mix: 0.1, room: 0.1 do
  synth :sound_in, sustain: 3600, amp: 0.2
end



##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##------------       RECIEVING INFORMATION FROM BROWSER                                             -------------------------------------------------------------------------
##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


live_loop :importdata do
  
  # sync functions from Mr Bomb Music Git hub athttps://github.com/mrbombmusic/sonic-pi-drum-rnn-gui.
  use_real_time
  a = sync "/osc*/notes"
  b = sync "/osc*/times"
  set :notes, a
  set :times, b
  puts a
  
  # my code
  
  
  
  ##| with_fx :echo, phase: 0.1  do
  with_fx :reverb, mix: 0.1, room: 0.1 do
    
    sync :heart_beat
    my_midi = a.first
    
    
    ##| use_synth :dsaw
    ##| in_thread do
    ##|   play my_midi, amp: 0.01, sustain: 20
    ##| end
    
    
    use_synth :kalimba
    in_thread do
      # NOWWW hopefully it syncs
      # and then we are going to use the first note we get to generate a list
      note_list_a = produce_notes my_midi, :major, r2
      r2.length.times do
        play note_list_a.tick, amp: 0.1
        sleep r2.tick
      end
    end
    
    use_synth :kalimba
    in_thread do
      
      # NOWWW hopefully it syncs
      # and then we are going to use the first note we get to generate a list
      note_list_c = produce_notes my_midi, :major, r5
      r5.length.times do
        play note_list_c.tick, amp: 0.1
        sleep r5.tick
      end
    end
    
  end
  ##| end
  
end


# we are going to stick this at the end of the file and go upwards from there

in_thread do
  loop do
    cue :heart_beat
    sleep 4
  end
end


