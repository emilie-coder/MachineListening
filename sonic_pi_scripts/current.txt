use_osc "localhost", 12004# Welcome to Sonic Pi


##-----------------------------------------------------------------------------------------------------------------
##------------       NOTE GENERATION     - NO DIRECTION                                        --------------------
##-----------------------------------------------------------------------------------------------------------------

# This function pseudorandomly produces notes in one key
define :produce_notes do |midi, maj_or_min, note_length_list|
  
  # CREDIT FOR THIS RANDOM GENERATOR: https://in-thread.sonic-pi.net/t/randomizing-the-random-seed-with-computer-clock-timer/5560
  use_random_seed Time.now.to_i
  
  # We learned about scale in class, but for further reference or to learn more, I reference:
  #     https://github.com/sonic-pi-net/sonic-pi/blob/dev/etc/doc/tutorial/08.3-Scales.md
  notes = scale(midi, maj_or_min)
  
  final_notes = []
  
  note_length_list.each do |length|
    note = choose(notes)
    final_notes.push(note)
  end
  
  return final_notes
end


##-----------------------------------------------------------------------------------------------------------------
##------------       NOTE GENERATION     -   WE WANT DIRECTION                                      ---------------
##-----------------------------------------------------------------------------------------------------------------
# This function pseudorandomly produces notes in one key that either ascends and descends or vice versa

define :produce_directional_notes do |midi, maj_or_min, note_length_list, direction|
  # CREDIT FOR THIS RANDOM GENERATOR: https://in-thread.sonic-pi.net/t/randomizing-the-random-seed-with-computer-clock-timer/5560
  use_random_seed Time.now.to_i
  
  # We learned about scale in class, but for further reference or to learn more, I reference:
  #     https://github.com/sonic-pi-net/sonic-pi/blob/dev/etc/doc/tutorial/08.3-Scales.md
  notes = scale(midi, maj_or_min)
  
  halfway = notes.length / 2
  final_notes = []
  
  
  # https://in-thread.sonic-pi.net/t/midilib-for-sonic-pi-and-generating-markov-chains-from-midis/5646/5
  # where each_with_index came from ^^ user Amiika
  
  note_length_list.each_with_index do |length, i|
    if direction == :up
      # Ascend up to the halfway point, then descend
      if i < halfway
        note = notes[i]
      else
        note = notes[notes.length - 1 - i]
      end
    else
      # Descend first, then ascend
      if i < halfway
        note = notes[notes.length - 1 - i]
      else
        note = notes[i]
      end
    end
    
    final_notes.push(note)
  end
  return final_notes
end



r1 = [1,1,1,1,1,1,1,1]

my_array = [1,1,1,1,1,1,1,1] * 3
r2 = my_array.map {|num| num / 3.0}

my_array = [1,1,1,1,1,1,1,1] * 7
r5 = my_array.map {|num| num / 7.0}


##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##------------       VOICE INPUT                                                   ------------------------------------------------------------------------------------------
##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

with_fx :reverb, mix: 0.1, room: 0.1 do
  synth :sound_in, sustain: 3600, amp: 0.2
end



##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##------------       RECIEVING INFORMATION FROM BROWSER                                             -------------------------------------------------------------------------
##---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


live_loop :importdata do
  
  # sync functions from Mr Bomb Music Git hub athttps://github.com/mrbombmusic/sonic-pi-drum-rnn-gui.
  use_real_time
  a = sync "/osc*/notes"
  b = sync "/osc*/times"
  set :notes, a
  set :times, b
  puts a
  
  # my code
  
  with_fx :echo, phase: 0.9  do
    with_fx :reverb, mix: 0.99, room: 0.9999 do
      
      sync :heart_beat
      
      
      
      my_midi = a.first
      
      
      use_synth :dsaw
      in_thread do
        play my_midi - 12, amp: 0.01, sustain: 20
      end
      
      
      use_synth :kalimba
      in_thread do
        # NOWWW hopefully it syncs
        # and then we are going to use the first note we get to generate a list
        note_list_a = produce_directional_notes my_midi, :minor, r2, :up
        r2.length.times do
          play note_list_a.tick, amp: 0.1
          sleep r2.tick
        end
      end
      
      use_synth :kalimba
      in_thread do
        # NOWWW hopefully it syncs
        # and then we are going to use the first note we get to generate a list
        note_list_a = produce_directional_notes my_midi, :minor, r2, :up
        r2.length.times do
          play note_list_a.tick, amp: 0.1
          sleep r2.tick
        end
      end
      
      use_synth :pretty_bell
      in_thread do
        
        # NOWWW hopefully it syncs
        # and then we are going to use the first note we get to generate a list
        note_list_c = produce_directional_notes my_midi, :minor, r5, :down
        r5.length.times do
          play note_list_c.tick, amp: 0.1
          sleep r5.tick
        end
      end
      
    end
  end
  
end


# we are going to stick this at the end of the file and go upwards from there

in_thread do
  loop do
    cue :heart_beat
    sleep 1
  end
end


